# -*- coding: utf-8 -*-
"""Codigo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tmQzeYKD7JnbB-DmjU_C7woMvlh6_Vsy
"""

#Elaborado por Luana Tomaz Accorsi e Carolina Pires Barcellos com auxílio do chatGPT para a disciplina de Medicina Nuclear ministrada pelo professor Doutor Marcelo
from moviepy.editor import vfx, VideoFileClip, concatenate_videoclips  #para conseguir tirar parte do vídeo
import cv2 #pra conseguir transformar o vídeo em imagem
from cv2 import VideoWriter, VideoWriter_fourcc  #permite edição de vídeo
import matplotlib.pyplot as plt  #permite a visualização das imagens
from imageio import imwrite #permite o ato de salvar as imagens e vídeo
import time #permite a correção de tempo no vídeo
import numpy as np  # Para manipulação de arrays


#inicializando as variáveis globais
intervalo=0
qtd=0
captura_imagem=VideoFileClip("video.mp4")
imagens = []


def intervalo_tempo():
  # Pergunta ao usuário o intervalo de tempo desejado entre as capturas de imagem
  intervalo = int(input("Digite o intervalo de tempo entre as capturas (em segundos): "))
  return intervalo

# Pergunta ao usuário o número de imagens a serem capturadas
def quantidade():
  qtd = int(input("Digite o número de imagens a serem capturadas (1-40): "))
  while(qtd > 40):
    input("O número máximo de aquisições de imagens por exame é 40.")
    quantidade()
  return qtd








#função para pegar a imagem
def take_photo(tempo):
    # Criação do VideoWriter
    fourcc = VideoWriter_fourcc(*'XVID')
    captura = captura_imagem.get_frame(0)
    altura, largura, _ = captura.shape
    video = cv2.VideoWriter('video4_questionario.mp4', fourcc, 30, (largura, altura))
    #variáveis locais
    ajuda = 1
    tempo_auxiliar=0
    i=0
    for j in range (qtd_imagens):
      tempo_auxiliar = tempo_auxiliar + tempo
      #seleção de frame
      captura = captura_imagem.get_frame(tempo_auxiliar)
      captura_rgb = cv2.cvtColor(captura, cv2.COLOR_RGB2BGR) #mantém as cores
      imagens.append(captura_rgb) #adiciona ao vetor
      # a partir daqui é pra salvar e mostrar a imagem
      # Salvando a imagem
      imwrite(f"Imagem_{j+1}.png", captura)
      i+=1
      for _ in range(int(1.2 * qtd_imagens)):  # Duração em segundos multiplicada pela taxa de quadros
            video.write(captura_rgb)
       # Adiciona o frame ao vídeo
      video.write(captura)
      ajuda+=1
    video.release()  # Libera o vídeo



    for a2 in range(qtd_imagens):
        plt.axis('off')  # Tira eixos
        plt.imshow(cv2.cvtColor(imagens[a2], cv2.COLOR_BGR2RGB))  # Mostra a imagem atual
        plt.show()  # Exibe a imagem

    print("A aquisição de imagens foi finalizada.")
    # Salvar o mosaico se necessário
    mosaico=criar_mosaico(imagens, num_colunas=5)
    cv2.imwrite('mosaico_imagens.png', mosaico)
    # Mostrar o mosaico
    plt.axis('off')  # Tira eixos
    plt.imshow(cv2.cvtColor(mosaico, cv2.COLOR_BGR2RGB))   # Converte BGR para RGB
    plt.show()  # Exibe o mosaico

def criar_mosaico(imagens, num_colunas=5):
    altura, largura, _ = imagens[0].shape
    num_imagens = len(imagens)
    num_linhas = (num_imagens + num_colunas - 1) // num_colunas  # Arredonda para cima

    # Criar uma imagem em branco para o mosaico
    mosaico = np.zeros((num_linhas * altura, num_colunas * largura, 3), dtype=np.uint8)

    # Preencher a imagem do mosaico
    for idx, img in enumerate(imagens):
        row = idx // num_colunas
        col = idx % num_colunas
        # Redimensionar a imagem para o tamanho adequado
        img_redimensionada = cv2.resize(img, (largura, altura), interpolation=cv2.INTER_AREA)
        mosaico[row * altura:(row + 1) * altura, col * largura:(col + 1) * largura] = img_redimensionada

    return mosaico

intervalo = intervalo_tempo()
qtd_imagens = quantidade()
take_photo(intervalo)